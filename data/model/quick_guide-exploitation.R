# ******************************************************************************
# Created: 04-Apr-2018
# Author:  J. DuBois
# Contact: jason.dubois@wildlife.ca.gov
# Purpose: quick guide to understand exploitation (harvest rate) calculation &
#          to understand how to prepare data (releases & returns) for use in
#          such calculation; plus understand how to calculate response rate for
#          lower $$ tags; S. Blackburn supplied only the algorithms, not code or
#          output, so herein is my best guess (from reading S. Blackburn
#          narrative [thesis]) on how to estimate exploitation
# ******************************************************************************

# TODO: develop function to subset on criteria (age or length & first-year
#       angler tag returns)
# TODO: develop function to create (from subsetted data) count by tag value of
#       released & returned (angler returns)
# TODO: develop function to calculate response rate
# TODO: develop function to calculate exploitation rate with variance
# TODO: develop function(s) to calculate other metrics (e.g., instantaneous 
#       fishing mortality [F in Ricker])
# TODO: ?


# soure files -------------------------------------------------------------

source(file = "source/methods_record_matching.R")

# load data ---------------------------------------------------------------

# tag releases & tag returns (angler)
SturgeonAll <- readRDS(file = "data/tagging/SturgeonAll.rds")
AnglerTagReturn <- readRDS(file = "data/tagging/AnglerTagReturn.rds")

# some return info --------------------------------------------------------

# record match
recs_match <- MatchRecords(
  df1 = SturgeonAll[SturgeonAll[["StuType"]] %in% "Tag", ],
  df2 = AnglerTagReturn,
  onFields = c("RelYear", "TagNum")
)


sum(!is.na(recs_match[["Match"]]))
sum(table(recs_match[["Match"]]) > 1)

which(!(1:3202 %in% sort(recs_match[["Match"]])))



dup_tags <- AnglerTagReturn[["TagNum"]][duplicated(AnglerTagReturn[["TagNum"]])]

AnglerTagReturn[AnglerTagReturn[["TagNum"]] %in% dup_tags, ]

# subset release data for WST & tags only ---------------------------------

# for now, I'll just use these fields for released sturgeon, may add more later
# but now is just preliminary testing (proof of concept kind of thing)
stu_all_cols <- c(
  "RelYear", "RelDate", "TagNum",
  "TagVal", "FL", "TL"
)

SturgeonAll <- subset(
  SturgeonAll,
  subset = StuType == "Tag" & Species == "White",
  select = stu_all_cols
)

# match release & return records ------------------------------------------

# because of some duplicate tag numbers released in separate years, we need to
# match release records with return records based on RelYear + TagNum

match_fields <- c("RelYear", "TagNum")

index <- match(
  x = Reduce(paste, x = SturgeonAll[, match_fields]),
  table = Reduce(paste, x = AnglerTagReturn[, match_fields])
)

# add angler tag return fields --------------------------------------------

# using the index created above add desired fields from AnglerTagReturn

# ********************************************************************
# run below to check -- should both be TRUE, if not figure out why
# 
# test <- AnglerTagReturn[index, "TagNum"]
# test2 <- AnglerTagReturn[index, "RelYear"]
# 
# identical(SturgeonAll$TagNum[!is.na(test)], test[!is.na(test)])
# identical(SturgeonAll$RelYear[!is.na(test2)], test2[!is.na(test2)])
# 
# rm(test, test2)
# 
# ********************************************************************

# don't really need to add these fields to SturgeonAll
# SturgeonAll$DateCaptured <- AnglerTagReturn[index, "DateCaptured"]
# SturgeonAll$DAL <- AnglerTagReturn[index, "DAL"]
# SturgeonAll$RetYear <- AnglerTagReturn[index, "RetYear"]


date_captured <- AnglerTagReturn[index, "DateCaptured"]
days_at_large <- AnglerTagReturn[index, "DAL"]
return_year <- AnglerTagReturn[index, "RetYear"]


# subset on criteria: age or length & first year tag returns --------------

# S. Blackburn used only tags returned within 1 year of released (first-year tag
# returns) & used only White Sturgeon possibly available for harvest during this
# 1-year period --- S. Blackburn used age to do this (ages 9.2-15.4) & these are
# the ages that correspond to the current slot limit (actually it's 10.2-15.4,
# but 9.2 allows for growth into the slot limit), it's not entirely clear how S.
# Blackburn accomplished this as ages are in whole numbers, when asked (e-mail)
# S. Blackburn said "I just used age 15 as the cutoff.", so I'll likley need to
# come up with some good logic on how to use fish available for harvest (length
# or age ??), for now I'll use only first-year returns & implement length or age
# cutoff later (with more noodling!)

# for now just using current slot as cutoff

# F = tag not returned OR tag returned but not first year, T = first year
# SturgeonAll$UseReturn <- SturgeonAll[["RetYear"]] %in% 1
# SturgeonAll$UseLength <- SturgeonAll[["FL"]] %in% 102:152

# contain data in matrix for ease of use in aggregate()
mat_rel_ret <- matrix(
  data = c(
    SturgeonAll[["FL"]] %in% 102:152,
    return_year %in% 1 & SturgeonAll[["FL"]] %in% 102:152
  ),
  nrow = nrow(SturgeonAll),
  ncol = 2,
  dimnames = list(NULL, c("Rel", "Ret"))
)

# TagVal -1 for some, I think this is a PIT tag & warrants investigation
sum_rel_ret <- aggregate(
  formula = mat_rel_ret ~ RelYear + TagVal,
  data = SturgeonAll,
  subset = RelYear > 1997 & TagVal > 0,
  FUN = sum
)

# sum_rel_ret <- sum_rel_ret[order(sum_rel_ret[["RelYear"]]), ]
# rownames(sum_rel_ret) <- NULL

# calculate reporting rate ------------------------------------------------

# simply (as a first step) we just divide Ret by Rel

sum_rel_ret$RetRate <- sum_rel_ret[["Ret"]] / sum_rel_ret[["Rel"]]

# tinkering below, but it's the same old story: with 3 tags & assuming the
# highest $ is 100% return adjusted tag returns is equivalent to taking 'n' of
# highest $ returns & multiplying by 3

# 24-May-2018: still puzzled as to how S. Blackburn corrected for non-response;
# it's not exactly clear (to me) in her thesis what values she used when&where

lapply(split(sum_rel_ret, f = sum_rel_ret[["RelYear"]]), FUN = function(d) {
  
  max_reward <- max(d[["TagVal"]])
  
  max_response <- which.max(d[["RetRate"]])
  
  # d[["TagVal"]][max_response]
  
  rr <- d[["RetRate"]] / d[["RetRate"]][max_response]

  ret_adj <- d[["Ret"]] / rr

  # including adjustment for tag loss (10%) & tagging mortaility (1%)
  mu <- sum(ret_adj, na.rm = TRUE) / (sum(d[["Rel"]]) * 0.9 * 0.99)
  
  list(
    MaxReward = max_reward,
    MaxRewardResp = d[["TagVal"]][max_response],
    AdjustedRet = rbind(Orig = d[["Ret"]], Adj = ret_adj),
    mu = mu
  )
  
})


